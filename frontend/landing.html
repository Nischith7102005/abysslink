<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AbyssLink | Secure Transmission Layer</title>
    
    <!-- IMPORTS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;400;600;800&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #000000;
            --text-main: #ffffff;
            --text-dim: #888888;
            --accent: #ffffff;
            --border: #1a1a1a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg);
            color: var(--text-main);
            font-family: 'Manrope', sans-serif;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            cursor: default;
        }

        /* STAGE */
        #webgl-stage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
        }

        /* DEEP VIGNETTE FOR READABILITY */
        .deep-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 20%, var(--bg) 95%);
            z-index: 1;
            pointer-events: none;
        }

        /* NAVIGATION */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 2rem 4rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .brand {
            font-family: 'Space Mono', monospace;
            font-weight: 700;
            letter-spacing: -0.05em;
            font-size: 1.2rem;
            text-transform: uppercase;
            mix-blend-mode: difference;
        }

        .nav-items a {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-main);
            text-decoration: none;
            margin-left: 2rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .nav-items a:hover { opacity: 1; }

        /* SECTIONS */
        section {
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center; /* CENTERED ALIGNMENT */
            padding: 0 8rem;
            z-index: 10;
            text-align: center;
        }

        .content-wrapper {
            max-width: 900px;
            opacity: 0;
            transform: translateY(30px);
        }

        /* TYPOGRAPHY */
        h1 {
            font-size: clamp(4rem, 12vw, 9rem);
            font-weight: 800;
            line-height: 0.85;
            letter-spacing: -0.04em;
            margin-bottom: 2rem;
            text-transform: uppercase;
            color: var(--text-main);
        }

        h2 {
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 200;
            margin-bottom: 1.5rem;
            letter-spacing: -0.03em;
            color: var(--text-main);
        }

        p {
            font-size: 1.1rem;
            color: var(--text-dim);
            line-height: 1.7;
            margin-bottom: 2rem;
            font-weight: 300;
        }

        /* DECIPHER GLITCH TEXT */
        .decipher-text {
            display: inline-block;
        }

        /* LAYOUTS */
        .grid-3 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 3rem;
            margin-top: 4rem;
            text-align: left;
        }

        .card {
            padding: 2rem 0;
            border-top: 1px solid var(--border);
            transition: border-color 0.3s ease;
        }

        .card:hover {
            border-color: var(--accent);
        }

        .card h3 {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            margin-bottom: 1rem;
            letter-spacing: 0.15em;
            color: var(--text-main);
        }

        .card p {
            font-size: 0.95rem;
            color: var(--text-dim);
            line-height: 1.5;
        }

        /* BUTTONS */
        .btn {
            display: inline-block;
            background: transparent;
            border: 1px solid var(--text-main);
            color: var(--text-main);
            padding: 1rem 3rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            margin-top: 2rem;
            text-decoration: none;
        }

        .btn:hover {
            background: var(--text-main);
            color: var(--bg);
            transform: scale(1.05);
        }

        /* ABOUT SECTION (SMALL, LAST) */
        .about-footer {
            padding: 5rem 8rem;
            background: #050505;
            border-top: 1px solid var(--border);
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 4rem;
            z-index: 20;
            position: relative;
            text-align: left;
        }

        .footer-brand h3 {
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-bottom: 1rem;
        }

        .footer-brand p {
            font-size: 0.9rem;
            color: #444;
            max-width: 300px;
            line-height: 1.5;
        }

        .footer-links {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .link-col h4 {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 1rem;
        }

        .link-col a {
            display: block;
            color: var(--text-dim);
            text-decoration: none;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            transition: color 0.3s;
        }

        .link-col a:hover { color: var(--text-main); }

        @media (max-width: 1024px) {
            section { padding: 0 4rem; }
            .about-footer { padding: 4rem; grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            .grid-3 { grid-template-columns: 1fr; }
            .footer-links { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div id="webgl-stage"></div>
    <div class="deep-vignette"></div>

    <nav>
        <div class="brand">AbyssLink</div>
        <div class="nav-items">
            <a href="#infrastructure">System</a>
            <a href="#security">Protocol</a>
            <a href="#access">Connect</a>
        </div>
    </nav>

    <!-- HERO SECTION: CENTERED -->
    <section id="hero">
        <div class="content-wrapper">
            <!-- TITLE IS ABYSSLINK AND CENTERED -->
            <h1 class="decipher-text" data-value="ABYSSLINK">ABYSSLINK</h1>
            <p>
                The invisible layer of the internet. 
                Encrypted, ephemeral, and completely untraceable communication infrastructure.
            </p>
            <a href="#access" class="btn">Enter The Void</a>
        </div>
    </section>

    <!-- INFRASTRUCTURE SECTION -->
    <section id="infrastructure">
        <div class="content-wrapper">
            <h2>Digital Stealth</h2>
            <p style="max-width: 500px;">
                We operate in the shadows. Our architecture utilizes non-persistent memory nodes that self-destruct immediately after transmission. No trace. No footprint.
            </p>
            <div class="grid-3">
                <div class="card">
                    <h3>Volatile Storage</h3>
                    <p>Data never touches a hard drive. It exists only in RAM, ensuring physical impossibility of recovery.</p>
                </div>
                <div class="card">
                    <h3>Entropic Routing</h3>
                    <p>Traffic paths are generated randomly and dissolved instantly, preventing traffic analysis.</p>
                </div>
                <div class="card">
                    <h3>Zero-Knowledge</h3>
                    <p>We do not know who you are, what you send, or who you connect to.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- SECURITY SECTION -->
    <section id="security">
        <div class="content-wrapper">
            <h2>Tactical Security</h2>
            <p style="max-width: 600px; margin-bottom: 3rem;">
                Our cryptographic standards are military-grade. We employ AES-256 for content and elliptic-curve protocols for key exchange.
            </p>
            <div class="grid-3" style="text-align: left;">
                <div class="card">
                    <h3>Handshake</h3>
                    <p>Secure key exchange happens milliseconds before data flows. Keys are discarded upon session end.</p>
                </div>
                <div class="card">
                    <h3>Payload</h3>
                    <p>All messages are encapsulated in noise packets, indistinguishable from standard web traffic.</p>
                </div>
                <div class="card">
                    <h3>Purge</h3>
                    <p>Every 24 hours, or instantly upon command, the entire session is shredded.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- ACCESS SECTION -->
    <section id="access">
        <div class="content-wrapper">
            <h2 class="decipher-text" data-value="READY_TO_VANISH">Ready To Vanish?</h2>
            <p>
                Initiate a secure session now. No registration required. No email needed. Just pure connection.
            </p>
            <button class="btn" style="margin-top: 3rem;">Initialize Link</button>
        </div>
    </section>

    <!-- ABOUT SECTION (SMALL, LAST) -->
    <footer class="about-footer">
        <div class="footer-brand">
            <h3>AbyssLink</h3>
            <p>
                Designed for the digital warrior. We provide the tools to communicate freely in a monitored world. 
                Our code is open source; our philosophy is absolute privacy.
            </p>
        </div>
        <div class="footer-links">
            <div class="link-col">
                <h4>Network</h4>
                <a href="#">Nodes Status</a>
                <a href="#">Encryption Keys</a>
                <a href="#">Whitepaper</a>
            </div>
            <div class="link-col">
                <h4>Legal</h4>
                <a href="#">Terms of Service</a>
                <a href="#">Privacy Policy</a>
                <a href="#">Canary Warrant</a>
            </div>
        </div>
    </footer>

    <script>
        // --- DECIPHER EFFECT FOR TITLES ---
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
        
        document.querySelectorAll('.decipher-text').forEach(element => {
            const originalText = element.getAttribute('data-value');
            let iterations = 0;

            const interval = setInterval(() => {
                element.innerText = originalText.split("")
                    .map((letter, index) => {
                        if(index < iterations) {
                            return originalText[index];
                        }
                        return chars[Math.floor(Math.random() * chars.length)];
                    })
                    .join("");
                
                if(iterations >= originalText.length) { 
                    clearInterval(interval);
                }
                
                iterations += 1/3;
            }, 30);
        });

        // --- THREE.JS DETAILED SCENE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); // Deep fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('webgl-stage').appendChild(renderer.domElement);

        // GROUPS FOR SECTIONS
        const heroGroup = new THREE.Group();
        const infraGroup = new THREE.Group();
        const voidGroup = new THREE.Group();
        
        scene.add(heroGroup);
        scene.add(infraGroup);
        scene.add(voidGroup);

        // --- HERO GROUP: TERRAIN + PARTICLES ---
        
        // 1. Wireframe Terrain
        const terrainGeo = new THREE.PlaneGeometry(150, 150, 60, 60);
        const terrainMat = new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: true, transparent: true, opacity: 0.15 });
        const terrain = new THREE.Mesh(terrainGeo, terrainMat);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = -15;
        
        // Deform terrain to look like mountains
        const pos = terrainGeo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            const z = pos.getZ(i);
            const x = pos.getX(i);
            // Random height displacement
            const noise = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 5 + Math.random() * 2;
            pos.setZ(i, z + noise);
        }
        terrainGeo.computeVertexNormals();
        heroGroup.add(terrain);

        // 2. Floating Dust Particles (High Detail)
        const dustGeo = new THREE.BufferGeometry();
        const dustCount = 4000;
        const dustPos = new Float32Array(dustCount * 3);
        const dustSizes = new Float32Array(dustCount);
        
        for(let i=0; i<dustCount*3; i++) {
            dustPos[i] = (Math.random() - 0.5) * 200;
        }
        for(let i=0; i<dustCount; i++) {
            dustSizes[i] = Math.random();
        }

        dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
        const dustMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        const dust = new THREE.Points(dustGeo, dustMat);
        heroGroup.add(dust);

        // 3. Monoliths (Detailed Shapes)
        const monoGeo = new THREE.TetrahedronGeometry(2, 0);
        const monoMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0 });
        const monoliths = [];
        
        for(let i=0; i<15; i++) {
            const m = new THREE.Mesh(monoGeo, monoMat.clone());
            m.position.set((Math.random()-0.5)*60, (Math.random()-0.5)*30, (Math.random()-0.5)*40);
            m.userData = { speed: Math.random() * 0.02, axis: Math.random() };
            monoliths.push(m);
            infraGroup.add(m);
        }

        // --- INFRA GROUP: CONNECTED NETWORK ---
        const nodeGeo = new THREE.IcosahedronGeometry(1, 0);
        const nodeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0 });
        const nodes = [];
        
        for(let i=0; i<30; i++) {
            const n = new THREE.Mesh(nodeGeo, nodeMat.clone());
            n.position.set((Math.random()-0.5)*50, (Math.random()-0.5)*30, (Math.random()-0.5)*30);
            n.scale.setScalar(Math.random() * 2 + 1);
            infraGroup.add(n);
            nodes.push(n);
        }

        // Connect nodes with lines
        const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
        const lineGeo = new THREE.BufferGeometry();
        const linePositions = new Float32Array(nodes.length * nodes.length * 3); // Max connections
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
        const connections = new THREE.LineSegments(lineGeo, lineMat);
        infraGroup.add(connections);

        // --- VOID GROUP: SIMPLE CLEAN LINES ---
        const voidGeo = new THREE.TorusKnotGeometry(15, 1, 200, 16);
        const voidMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0 });
        const knot = new THREE.Mesh(voidGeo, voidMat);
        voidGroup.add(knot);

        camera.position.z = 30;

        // --- GSAP SCROLL ANIMATION ---
        gsap.registerPlugin(ScrollTrigger);

        document.querySelectorAll('.content-wrapper').forEach(content => {
            gsap.to(content, {
                scrollTrigger: {
                    trigger: content,
                    start: "top 85%",
                    toggleActions: "play none none reverse"
                },
                opacity: 1,
                y: 0,
                duration: 1.2,
                ease: "power3.out"
            });
        });

        const timeline = gsap.timeline({
            scrollTrigger: {
                trigger: "body",
                start: "top top",
                end: "bottom bottom",
                scrub: 1.5
            }
        });

        timeline
            // HERO -> INFRA
            .to(camera.position, { z: 40, y: 10, x: 10, duration: 3 })
            .to(heroGroup.position, { y: -20, duration: 3 }, 0)
            .to(terrainMat, { opacity: 0, duration: 2 }, 0)
            .to(dustMat, { opacity: 0.1, duration: 2 }, 0)
            .to(monoMat, { opacity: 0.15, duration: 2 }, 1)
            .to(nodeMat, { opacity: 0.1, duration: 2 }, 1)
            .to(lineMat, { opacity: 0.05, duration: 2 }, 1.5)

            // INFRA -> VOID
            .to(camera.position, { z: 50, y: -10, x: -10, duration: 3 }, 3)
            .to(monoMat, { opacity: 0, duration: 2 }, 3)
            .to(nodeMat, { opacity: 0, duration: 2 }, 3)
            .to(lineMat, { opacity: 0, duration: 2 }, 3)
            .to(voidMat, { opacity: 0.1, duration: 2 }, 4)
            .to(knot.rotation, { z: Math.PI, duration: 3 }, 3)

            // VOID -> FOOTER
            .to(camera.position, { z: 20, y: 0, x: 0, duration: 3 }, 6)
            .to(voidMat, { opacity: 0, duration: 2 }, 7);


        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.0005;

            // Terrain Movement
            terrain.position.z = (time * 5) % 10; 
            
            // Dust movement
            const positions = dustGeo.attributes.position.array;
            for(let i=0; i<dustCount; i++) {
                positions[i*3 + 1] += Math.sin(time * 2 + i) * 0.01;
            }
            dustGeo.attributes.position.needsUpdate = true;

            // Monoliths floating
            monoliths.forEach(m => {
                m.rotation.x += 0.005;
                m.rotation.y += 0.005;
                m.position.y += Math.sin(time + m.userData.axis) * 0.02;
            });

            // Network pulsing
            nodes.forEach((n, i) => {
                const scale = 1 + Math.sin(time * 3 + i) * 0.2;
                n.scale.setScalar(scale);
                
                // Update lines logic (simple version for performance)
                // Connecting nodes randomly creates dynamic "data flow" visual
            });

            // Void Knot
            knot.rotation.x += 0.002;
            knot.rotation.y += 0.003;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
