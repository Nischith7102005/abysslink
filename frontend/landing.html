<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AbyssLink | Secure Transmission Layer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;400;600;800&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

<!-- Three.js and postprocessing -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "postprocessing": "https://unpkg.com/postprocessing@6.34.1/build/postprocessing.esm.js"
  }
}
</script>

<style>
:root {
    --bg: #050505;
    --surface: #0a0a0a;
    --text-main: #ffffff;
    --text-dim: #888888;
    --border: #222222;
    --ease-out: cubic-bezier(0.23, 1, 0.32, 1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    scroll-behavior: smooth;
}

body {
    background-color: var(--bg);
    color: var(--text-main);
    font-family: 'Manrope', sans-serif;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
}

/* Hyperspeed background for hero */
#hyperspeed-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    z-index: -2;
    overflow: hidden;
}

#hyperspeed-container canvas {
    width: 100% !important;
    height: 100% !important;
}

/* Original background for other sections */
.background-wrapper {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -3;
    overflow: hidden;
    opacity: 0;
    transition: opacity 0.5s ease;
}

.background-wrapper.visible {
    opacity: 1;
}

#bg-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('https://i.ibb.co/TMkPJDsN/1.jpg') center/cover no-repeat;
    filter: blur(12px) brightness(0.6);
    transform: scale(1.1) translate3d(0, 0, 0);
    z-index: -2;
    will-change: filter;
    backface-visibility: hidden;
}

#warrior-container {
    position: fixed;
    bottom: -15vh;
    left: -2%;
    right: 0;
    width: 100%;
    height: 100vh;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    z-index: 1;
    pointer-events: none;
    overflow: hidden;
    background: transparent;
}

#warrior-img {
    position: relative;
    height: 100vh;
    width: auto;
    max-width: 100%;
    object-fit: contain;
    object-position: center bottom;
    display: block;
    background: transparent;
    mix-blend-mode: screen;
    border: none !important;
    outline: none !important;
    box-shadow: none !important;
    filter: drop-shadow(0 0 20px rgba(0,0,0,0.5));
    mask-image: linear-gradient(to bottom,
        black 0%,
        black 85%,
        transparent 100%);
    -webkit-mask-image: linear-gradient(to bottom,
        black 0%,
        black 85%,
        transparent 100%);
    will-change: opacity, transform;
    transform-origin: center bottom;
    transform: translate3d(0, 0, 0);
    backface-visibility: hidden;
    margin: 0 auto;
}

#sword-container {
    position: fixed;
    bottom: -18vh;
    left: -8%;
    width: 100%;
    height: 115vh;
    display: flex;
    align-items: flex-end;
    justify-content: flex-start;
    padding-left: 0;
    z-index: 5;
    pointer-events: none;
    overflow: hidden;
    will-change: transform;
    contain: layout style paint;
}

#sword-img {
    position: relative;
    height: 100vh;
    width: auto;
    max-height: none;
    object-fit: contain;
    object-position: bottom left;
    display: block;
    opacity: 0;
    filter: drop-shadow(0 0 20px rgba(255,255,255,0.25));
    will-change: opacity, transform;
    transform: translate3d(0, 60px, 0);
    backface-visibility: hidden;
    mix-blend-mode: normal;
    mask-image: linear-gradient(to bottom,
        transparent 0%,
        black 5%,
        black 100%);
    -webkit-mask-image: linear-gradient(to bottom,
        transparent 0%,
        black 5%,
        black 100%);
}

.vignette {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, transparent 30%, rgba(5,5,5,0.7) 100%);
    z-index: 2;
    pointer-events: none;
}

.menu-toggle {
    position: fixed;
    top: 2rem;
    left: 4rem;
    width: 32px;
    height: 24px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    cursor: pointer;
    z-index: 1001;
}

.menu-toggle span {
    width: 100%;
    height: 2px;
    background: var(--text-main);
    transition: all 0.3s ease;
}

.menu-toggle.active span:nth-child(1) {
    transform: translateY(11px) rotate(45deg);
}

.menu-toggle.active span:nth-child(2) {
    opacity: 0;
}

.menu-toggle.active span:nth-child(3) {
    transform: translateY(-11px) rotate(-45deg);
}

.menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(5, 5, 5, 0.98);
    backdrop-filter: blur(20px);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 3rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.4s ease, visibility 0.4s ease;
}

.menu-overlay.active {
    opacity: 1;
    visibility: visible;
}

.menu-overlay a {
    color: var(--text-main);
    text-decoration: none;
    font-family: 'Space Mono', monospace;
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    opacity: 0.7;
    transition: opacity 0.3s ease;
    cursor: pointer;
}

.menu-overlay a:hover {
    opacity: 1;
}

.sticky-nav {
    position: fixed;
    top: 2rem;
    right: 4rem;
    z-index: 500;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.sticky-nav a {
    color: var(--text-dim);
    text-decoration: none;
    opacity: 0.5;
    transition: all 0.3s ease;
    padding-right: 1rem;
    border-right: 2px solid transparent;
}

.sticky-nav a.active {
    color: var(--text-main);
    opacity: 1;
    border-right-color: var(--text-main);
}

section {
    position: relative;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 0 8rem;
    z-index: 10;
    background: transparent;
}

#hero {
    background: transparent;
}

#hero .content-wrapper {
    text-align: center;
    margin: 0 auto;
    z-index: 20;
    margin-top: 5vh;
}

.content-wrapper {
    max-width: 900px;
    opacity: 0;
    transform: translateY(20px);
    margin: 0 auto;
    position: relative;
    z-index: 15;
    will-change: transform, opacity;
    backface-visibility: hidden;
}

h1, h2, h3 {
    font-family: 'Space Mono', monospace;
    font-weight: 200;
    letter-spacing: -0.04em;
    text-transform: uppercase;
}

h1 {
    font-size: clamp(3.5rem, 10vw, 7rem);
    line-height: 0.9;
    margin-bottom: 1.5rem;
    text-shadow: 0 0 30px rgba(0,0,0,1);
}

h2 {
    font-size: clamp(2rem, 4vw, 3.5rem);
    margin-bottom: 2rem;
    text-shadow: 0 2px 20px rgba(0,0,0,0.8);
}

p.lead {
    font-size: 1.25rem;
    color: #ddd;
    line-height: 1.6;
    margin-bottom: 3rem;
    font-weight: 300;
    text-shadow: 0 2px 10px rgba(0,0,0,1);
}

.glitch-text {
    position: relative;
}

.glitch-char {
    display: inline-block;
    position: relative;
    will-change: opacity, transform;
}

.button-group {
    display: flex;
    gap: 2rem;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 2rem;
}

.glass-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 2rem;
    margin-top: 3rem;
}

.glass-pane {
    background: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding: 2.5rem;
    border-radius: 4px;
    transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
    position: relative;
    will-change: transform, background, border-color;
    backface-visibility: hidden;
}

.glass-pane:hover {
    background: rgba(0, 0, 0, 0.75);
    border-color: rgba(255, 255, 255, 0.25);
    transform: translateY(-5px);
}

.glass-pane h3 {
    font-size: 1rem;
    margin-bottom: 1rem;
    color: var(--text-main);
    border-bottom: 1px solid rgba(255,255,255,0.1);
    padding-bottom: 0.5rem;
    display: inline-block;
}

.glass-pane p {
    font-size: 0.95rem;
    color: var(--text-dim);
    line-height: 1.6;
}

.grid-3 {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 2rem;
    margin-top: 4rem;
}

.card {
    border-top: 1px solid var(--border);
    padding-top: 1.5rem;
    transition: border-color 0.3s ease, background 0.3s ease, transform 0.3s ease;
    background: rgba(0, 0, 0, 0.5);
    padding: 1.5rem;
    backdrop-filter: blur(5px);
    will-change: transform, background, border-color;
    backface-visibility: hidden;
}

.card:hover {
    border-color: var(--text-main);
    background: rgba(0, 0, 0, 0.7);
    transform: translateY(-3px);
}

.card h3 {
    font-size: 0.9rem;
    margin-bottom: 1rem;
}

.card p {
    font-size: 1rem;
    color: var(--text-dim);
    line-height: 1.5;
}

.btn {
    display: inline-flex;
    align-items: center;
    background: var(--text-main);
    color: var(--bg);
    padding: 1rem 2.5rem;
    font-family: 'Space Mono', monospace;
    font-size: 0.8rem;
    text-transform: uppercase;
    font-weight: 700;
    border: none;
    cursor: pointer;
    transition: transform 0.3s var(--ease-out);
    z-index: 30;
    text-decoration: none;
    will-change: transform;
}

.btn:hover {
    transform: translateX(10px);
}

.btn-secondary {
    background: rgba(0,0,0,0.6);
    color: var(--text-main);
    border: 1px solid var(--border);
}

.btn-secondary:hover {
    background: var(--text-main);
    color: var(--bg);
    transform: translateX(0) scale(1.05);
}

.about-section {
    min-height: 60vh;
    background: rgba(5, 5, 5, 0.9);
    border-top: 1px solid var(--border);
    padding: 4rem 8rem;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-wrap: wrap;
    z-index: 20;
    backdrop-filter: blur(10px);
}

.footer-brand {
    width: 100%;
    margin-bottom: 3rem;
}

.footer-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 2rem;
    width: 100%;
}

.footer-col h4 {
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    text-transform: uppercase;
    color: var(--text-dim);
    margin-bottom: 1rem;
}

.footer-col p, .footer-col a {
    font-size: 0.9rem;
    color: var(--text-main);
    line-height: 1.8;
    text-decoration: none;
    display: block;
}

.footer-col a:hover {
    color: var(--text-dim);
}

@media (max-width: 1024px) {
    section { padding: 0 4rem; }
    .about-section { padding: 3rem 2rem; }
    .footer-grid { grid-template-columns: 1fr 1fr; }
    #warrior-container { bottom: -12vh; left: -8%; }
    #warrior-img { height: 95vh; }
    #sword-container {
        bottom: -15vh;
        left: -5%;
    }
    #sword-img {
        height: 95vh;
    }
    .menu-toggle { left: 2rem; }
    .sticky-nav { right: 2rem; }
    .glass-grid { grid-template-columns: repeat(2, 1fr); }
}

@media (max-width: 768px) {
    h1 { font-size: 2.5rem; }
    h2 { font-size: 2rem; }
    #warrior-container { bottom: -8vh; left: -5%; }
    #warrior-img { height: 90vh; }
    #sword-container {
        bottom: -12vh;
        left: -3%;
    }
    #sword-img {
        height: 85vh;
    }
    .button-group { gap: 1rem; }
    .sticky-nav { display: none; }
    .glass-grid { grid-template-columns: 1fr; }
    section { padding: 0 2rem; }
}

@media (max-width: 600px) {
    h1 { font-size: 2rem; }
    .about-section { padding: 2rem 1.5rem; }
    .footer-grid { grid-template-columns: 1fr; }
    #warrior-container { bottom: -5vh; left: -3%; }
    #warrior-img { height: 85vh; }
    #sword-container {
        bottom: -8vh;
        left: 0;
    }
    #sword-img { height: 75vh; }
    .menu-toggle { left: 1rem; top: 1rem; }
}
</style>
</head>
<body>

<script>
    if (history.scrollRestoration) {
        history.scrollRestoration = 'manual';
    }
    window.addEventListener('beforeunload', () => {
        window.scrollTo(0, 0);
    });
</script>

<!-- Hyperspeed Background for Hero -->
<div id="hyperspeed-container"></div>

<!-- Original Background (for other sections) -->
<div class="background-wrapper" id="originalBackground">
    <div id="bg-image"></div>
</div>

<div id="warrior-container">
    <img id="warrior-img" src="https://i.ibb.co/TMmNskSK/a-w.png" alt="Warrior">
</div>

<div id="sword-container">
    <img id="sword-img" src="https://image2url.com/r2/default/images/1767366955365-dc9faf5e-f348-49f3-b370-7caad31108b6.png" alt="Berserk Sword">
</div>

<div class="vignette"></div>

<div class="menu-toggle" id="menuToggle">
    <span></span>
    <span></span>
    <span></span>
</div>

<div class="sticky-nav">
    <a href="#hero" class="nav-item active" data-section="hero">Overview</a>
    <a href="#infrastructure" class="nav-item" data-section="infrastructure">Infrastructure</a>
    <a href="#security" class="nav-item" data-section="security">Security</a>
    <a href="#implementation" class="nav-item" data-section="implementation">Implementation</a>
    <a href="#contact" class="nav-item" data-section="contact">Contact</a>
</div>

<div class="menu-overlay" id="menuOverlay">
    <a href="rooms.html">Get Into The Abyss</a>
    <a href="#infrastructure" onclick="closeMenu();">Features</a>
</div>

<section id="hero">
    <div class="content-wrapper">
        <h1 class="glitch-text" data-text="ABYSSLINK">ABYSSLINK</h1>
        <p class="lead">
            An ephemeral communication layer designed for professionals who require absolute stealth.<br>
            No persistent storage. No logs. Just silence.
        </p>
        <div class="button-group">
            <a href="rooms.html" class="btn">Get Into The Abyss</a>
        </div>
    </div>
</section>

<section id="infrastructure">
    <div class="content-wrapper">
        <h2>STRUCTURED ANONYMITY.</h2>
        <p style="color: var(--text-dim); margin-bottom: 2rem;">
            Our architecture prioritizes complete anonymity through distributed protocols and zero-knowledge proof systems.
        </p>
        <div class="glass-grid">
            <div class="glass-pane">
                <h3>01 // Zero-Persistence</h3>
                <p>Messages never stored - real-time broadcast only. 24-hour automatic expiration with instant destruction capability.</p>
            </div>
            <div class="glass-pane">
                <h3>02 // Complete Anonymity</h3>
                <p>No accounts, no usernames, no identity tracking. All participants appear as encrypted nodes in the network.</p>
            </div>
            <div class="glass-pane">
                <h3>03 // Room Keys</h3>
                <p>Join via a Room Key + Password. No invites. No tracking. Just direct access.</p>
            </div>
            <div class="glass-pane">
                <h3>04 // Real-Time Encryption</h3>
                <p>End-to-end encrypted messaging with ephemeral file sharing. All secrets hashed with SHA-256.</p>
            </div>
        </div>
    </div>
</section>

<section id="security">
    <div class="content-wrapper">
        <h2 id="absolute-privacy-trigger">ABSOLUTE PRIVACY.</h2>
        <p class="lead">
            In the modern digital landscape, surveillance is the default. We have built a system where privacy is the baseline.
        </p>
        <div class="grid-3">
            <div class="card">
                <h3>Hashed Secrets</h3>
                <p>All passwords and keys hashed with SHA-256. No plain-text storage. Rate-limited authentication.</p>
            </div>
            <div class="card">
                <h3>No User Accounts</h3>
                <p>Registration is surveillance. Session tokens only - scoped to room lifetime.</p>
            </div>
            <div class="card">
                <h3>No Message Storage</h3>
                <p>Messages broadcast in real-time only. Zero persistence. Once delivered, vanished.</p>
            </div>
            <div class="card">
                <h3>No Analytics</h3>
                <p>We don't track usage patterns, behaviors, or metadata. Your existence leaves no digital footprint.</p>
            </div>
            <div class="card">
                <h3>Rate Limiting</h3>
                <p>Brute-force protection: 5 attempts per 15 minutes. IP-based throttling.</p>
            </div>
            <div class="card">
                <h3>Complete Destruction</h3>
                <p>Room expiration purges all sessions, invites, messages, and files. Irrecoverable.</p>
            </div>
        </div>
    </div>
</section>

<section id="implementation">
    <div class="content-wrapper">
        <h2>HOW IT WORKS.</h2>
        <p class="lead">
            AbyssLink operates on a simple principle: communication should be ephemeral.
        </p>
        <div class="glass-grid">
            <div class="glass-pane">
                <h3>Step 1: Create Room</h3>
                <p>Generate a random Room Key. Set a password. Enter chat.</p>
            </div>
            <div class="glass-pane">
                <h3>Step 2: Share Key + Password</h3>
                <p>Send both to trusted participants via secure external channels.</p>
            </div>
            <div class="glass-pane">
                <h3>Step 3: Communicate</h3>
                <p>Messages and files are real-time only. Never stored. Never logged.</p>
            </div>
            <div class="glass-pane">
                <h3>Step 4: Vanish</h3>
                <p>Anyone can trigger full room destruction. Everything dissolves instantly.</p>
            </div>
        </div>
    </div>
</section>

<section id="contact" style="text-align: center; align-items: center;">
    <div class="content-wrapper" style="max-width: 100%; text-align: center;">
        <h2>READY TO VANISH?</h2>
        <p class="lead">Join the network that forgets.</p>
        <div class="button-group" style="justify-content: center;">
            <a href="rooms.html" class="btn">Get Into The Abyss</a>
        </div>
    </div>
</section>

<footer class="about-section">
    <div class="footer-brand">
        <h3>ABYSSLINK</h3>
        <p style="margin-top: 1rem; color: var(--text-dim); max-width: 400px; font-size: 0.9rem;">
            Founded on the principle that digital communication should mirror the transience of physical conversation. We build for the shadows.
        </p>
    </div>
    <div class="footer-grid">
        <div class="footer-col">
            <h4>Protocol</h4>
            <p>E2E Encryption</p>
            <p>Volatile Nodes</p>
            <p>Room Key + Password</p>
            <p>24hr Auto-Destruct</p>
        </div>
        <div class="footer-col">
            <h4>Features</h4>
            <p>Anonymous Chat</p>
            <p>File Sharing</p>
            <p>Instant Vanish</p>
            <p>Zero Logs</p>
        </div>
        <div class="footer-col">
            <h4>Legal</h4>
            <p>Terms of Service</p>
            <p>Privacy Policy</p>
            <p>Security Report</p>
            <p>Transparency</p>
        </div>
        <div class="footer-col">
            <h4>Access</h4>
            <a href="rooms.html">Get Started</a>
            <p>Documentation</p>
            <p>API Access</p>
        </div>
    </div>
    <div style="width: 100%; margin-top: 3rem; border-top: 1px solid var(--border); padding-top: 2rem; font-family: 'Space Mono'; font-size: 0.7rem; color: #333;">
        &copy; 2025 AbyssLink Systems. All rights reserved. No data stored.
    </div>
</footer>

<!-- Hyperspeed Effect Module -->
<script type="module">
import * as THREE from 'three';
import { BloomEffect, EffectComposer, EffectPass, RenderPass, SMAAEffect, SMAAPreset } from 'postprocessing';

// Hyperspeed Effect Options
const effectOptions = {
    onSpeedUp: () => {},
    onSlowDown: () => {},
    distortion: 'turbulentDistortion',
    length: 400,
    roadWidth: 10,
    islandWidth: 2,
    lanesPerRoad: 4,
    fov: 90,
    fovSpeedUp: 150,
    speedUp: 2,
    carLightsFade: 0.4,
    totalSideLightSticks: 20,
    lightPairsPerRoadWay: 40,
    shoulderLinesWidthPercentage: 0.05,
    brokenLinesWidthPercentage: 0.1,
    brokenLinesLengthPercentage: 0.5,
    lightStickWidth: [0.12, 0.5],
    lightStickHeight: [1.3, 1.7],
    movingAwaySpeed: [60, 80],
    movingCloserSpeed: [-120, -160],
    carLightsLength: [400 * 0.03, 400 * 0.2],
    carLightsRadius: [0.05, 0.14],
    carWidthPercentage: [0.3, 0.5],
    carShiftX: [-0.8, 0.8],
    carFloorSeparation: [0, 5],
    colors: {
        roadColor: 0x080808,
        islandColor: 0x0a0a0a,
        background: 0x000000,
        shoulderLines: 0xffffff,
        brokenLines: 0xffffff,
        leftCars: [0xd856bf, 0x6750a2, 0xc247ac],
        rightCars: [0x03b3c3, 0x0e5ea5, 0x324555],
        sticks: 0x03b3c3
    }
};

const nsin = val => Math.sin(val) * 0.5 + 0.5;

const turbulentUniforms = {
    uFreq: { value: new THREE.Vector4(4, 8, 8, 1) },
    uAmp: { value: new THREE.Vector4(25, 5, 10, 10) }
};

const distortions = {
    turbulentDistortion: {
        uniforms: turbulentUniforms,
        getDistortion: `
            uniform vec4 uFreq;
            uniform vec4 uAmp;
            float nsin(float val){
                return sin(val) * 0.5 + 0.5;
            }
            #define PI 3.14159265358979
            float getDistortionX(float progress){
                return (
                    cos(PI * progress * uFreq.r + uTime) * uAmp.r +
                    pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g
                );
            }
            float getDistortionY(float progress){
                return (
                    -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +
                    -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a
                );
            }
            vec3 getDistortion(float progress){
                return vec3(
                    getDistortionX(progress) - getDistortionX(0.0125),
                    getDistortionY(progress) - getDistortionY(0.0125),
                    0.
                );
            }
        `,
        getJS: (progress, time) => {
            const uFreq = turbulentUniforms.uFreq.value;
            const uAmp = turbulentUniforms.uAmp.value;

            const getX = p =>
                Math.cos(Math.PI * p * uFreq.x + time) * uAmp.x +
                Math.pow(Math.cos(Math.PI * p * uFreq.y + time * (uFreq.y / uFreq.x)), 2) * uAmp.y;

            const getY = p =>
                -nsin(Math.PI * p * uFreq.z + time) * uAmp.z -
                Math.pow(nsin(Math.PI * p * uFreq.w + time / (uFreq.z / uFreq.w)), 5) * uAmp.w;

            let distortion = new THREE.Vector3(
                getX(progress) - getX(progress + 0.007),
                getY(progress) - getY(progress + 0.007),
                0
            );
            let lookAtAmp = new THREE.Vector3(-2, -5, 0);
            let lookAtOffset = new THREE.Vector3(0, 0, -10);
            return distortion.multiply(lookAtAmp).add(lookAtOffset);
        }
    }
};

const random = base => {
    if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];
    return Math.random() * base;
};

const pickRandom = arr => {
    if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];
    return arr;
};

function lerp(current, target, speed = 0.1, limit = 0.001) {
    let change = (target - current) * speed;
    if (Math.abs(change) < limit) {
        change = target - current;
    }
    return change;
}

class CarLights {
    constructor(webgl, options, colors, speed, fade) {
        this.webgl = webgl;
        this.options = options;
        this.colors = colors;
        this.speed = speed;
        this.fade = fade;
    }

    init() {
        const options = this.options;
        let curve = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1));
        let geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);

        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);
        instanced.instanceCount = options.lightPairsPerRoadWay * 2;

        let laneWidth = options.roadWidth / options.lanesPerRoad;

        let aOffset = [];
        let aMetrics = [];
        let aColor = [];

        let colors = this.colors;
        if (Array.isArray(colors)) {
            colors = colors.map(c => new THREE.Color(c));
        } else {
            colors = new THREE.Color(colors);
        }

        for (let i = 0; i < options.lightPairsPerRoadWay; i++) {
            let radius = random(options.carLightsRadius);
            let length = random(options.carLightsLength);
            let speed = random(this.speed);

            let carLane = i % options.lanesPerRoad;
            let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;

            let carWidth = random(options.carWidthPercentage) * laneWidth;
            let carShiftX = random(options.carShiftX) * laneWidth;
            laneX += carShiftX;

            let offsetY = random(options.carFloorSeparation) + radius * 1.3;
            let offsetZ = -random(options.length);

            aOffset.push(laneX - carWidth / 2);
            aOffset.push(offsetY);
            aOffset.push(offsetZ);

            aOffset.push(laneX + carWidth / 2);
            aOffset.push(offsetY);
            aOffset.push(offsetZ);

            aMetrics.push(radius);
            aMetrics.push(length);
            aMetrics.push(speed);

            aMetrics.push(radius);
            aMetrics.push(length);
            aMetrics.push(speed);

            let color = pickRandom(colors);
            aColor.push(color.r);
            aColor.push(color.g);
            aColor.push(color.b);

            aColor.push(color.r);
            aColor.push(color.g);
            aColor.push(color.b);
        }

        instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false));
        instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false));
        instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));

        let material = new THREE.ShaderMaterial({
            fragmentShader: carLightsFragment,
            vertexShader: carLightsVertex,
            transparent: true,
            uniforms: Object.assign(
                {
                    uTime: { value: 0 },
                    uTravelLength: { value: options.length },
                    uFade: { value: this.fade }
                },
                this.webgl.fogUniforms,
                options.distortion.uniforms
            )
        });

        material.onBeforeCompile = shader => {
            shader.vertexShader = shader.vertexShader.replace(
                '#include <getDistortion_vertex>',
                options.distortion.getDistortion
            );
        };

        let mesh = new THREE.Mesh(instanced, material);
        mesh.frustumCulled = false;
        this.webgl.scene.add(mesh);
        this.mesh = mesh;
    }

    update(time) {
        this.mesh.material.uniforms.uTime.value = time;
    }
}

const carLightsFragment = `
    #define USE_FOG;
    ${THREE.ShaderChunk['fog_pars_fragment']}
    varying vec3 vColor;
    varying vec2 vUv; 
    uniform vec2 uFade;
    void main() {
        vec3 color = vec3(vColor);
        float alpha = smoothstep(uFade.x, uFade.y, vUv.x);
        gl_FragColor = vec4(color, alpha);
        if (gl_FragColor.a < 0.0001) discard;
        ${THREE.ShaderChunk['fog_fragment']}
    }
`;

const carLightsVertex = `
    #define USE_FOG;
    ${THREE.ShaderChunk['fog_pars_vertex']}
    attribute vec3 aOffset;
    attribute vec3 aMetrics;
    attribute vec3 aColor;
    uniform float uTravelLength;
    uniform float uTime;
    varying vec2 vUv; 
    varying vec3 vColor; 
    #include <getDistortion_vertex>
    void main() {
        vec3 transformed = position.xyz;
        float radius = aMetrics.r;
        float myLength = aMetrics.g;
        float speed = aMetrics.b;

        transformed.xy *= radius;
        transformed.z *= myLength;

        transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);
        transformed.xy += aOffset.xy;

        float progress = abs(transformed.z / uTravelLength);
        transformed.xyz += getDistortion(progress);

        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
        gl_Position = projectionMatrix * mvPosition;
        vUv = uv;
        vColor = aColor;
        ${THREE.ShaderChunk['fog_vertex']}
    }
`;

class LightsSticks {
    constructor(webgl, options) {
        this.webgl = webgl;
        this.options = options;
    }

    init() {
        const options = this.options;
        const geometry = new THREE.PlaneGeometry(1, 1);
        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);
        let totalSticks = options.totalSideLightSticks;
        instanced.instanceCount = totalSticks;

        let stickoffset = options.length / (totalSticks - 1);
        const aOffset = [];
        const aColor = [];
        const aMetrics = [];

        let colors = options.colors.sticks;
        if (Array.isArray(colors)) {
            colors = colors.map(c => new THREE.Color(c));
        } else {
            colors = new THREE.Color(colors);
        }

        for (let i = 0; i < totalSticks; i++) {
            let width = random(options.lightStickWidth);
            let height = random(options.lightStickHeight);
            aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());

            let color = pickRandom(colors);
            aColor.push(color.r);
            aColor.push(color.g);
            aColor.push(color.b);

            aMetrics.push(width);
            aMetrics.push(height);
        }

        instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false));
        instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));
        instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false));

        const material = new THREE.ShaderMaterial({
            fragmentShader: sideSticksFragment,
            vertexShader: sideSticksVertex,
            side: THREE.DoubleSide,
            uniforms: Object.assign(
                {
                    uTravelLength: { value: options.length },
                    uTime: { value: 0 }
                },
                this.webgl.fogUniforms,
                options.distortion.uniforms
            )
        });

        material.onBeforeCompile = shader => {
            shader.vertexShader = shader.vertexShader.replace(
                '#include <getDistortion_vertex>',
                options.distortion.getDistortion
            );
        };

        const mesh = new THREE.Mesh(instanced, material);
        mesh.frustumCulled = false;
        this.webgl.scene.add(mesh);
        this.mesh = mesh;
    }

    update(time) {
        this.mesh.material.uniforms.uTime.value = time;
    }
}

const sideSticksVertex = `
    #define USE_FOG;
    ${THREE.ShaderChunk['fog_pars_vertex']}
    attribute float aOffset;
    attribute vec3 aColor;
    attribute vec2 aMetrics;
    uniform float uTravelLength;
    uniform float uTime;
    varying vec3 vColor;
    mat4 rotationY( in float angle ) {
        return mat4(cos(angle), 0, sin(angle), 0,
                    0, 1.0, 0, 0,
                    -sin(angle), 0, cos(angle), 0,
                    0, 0, 0, 1);
    }
    #include <getDistortion_vertex>
    void main(){
        vec3 transformed = position.xyz;
        float width = aMetrics.x;
        float height = aMetrics.y;

        transformed.xy *= vec2(width, height);
        float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);

        transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;

        transformed.z += - uTravelLength + time;

        float progress = abs(transformed.z / uTravelLength);
        transformed.xyz += getDistortion(progress);

        transformed.y += height / 2.;
        transformed.x += -width / 2.;
        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
        gl_Position = projectionMatrix * mvPosition;
        vColor = aColor;
        ${THREE.ShaderChunk['fog_vertex']}
    }
`;

const sideSticksFragment = `
    #define USE_FOG;
    ${THREE.ShaderChunk['fog_pars_fragment']}
    varying vec3 vColor;
    void main(){
        vec3 color = vec3(vColor);
        gl_FragColor = vec4(color,1.);
        ${THREE.ShaderChunk['fog_fragment']}
    }
`;

class Road {
    constructor(webgl, options) {
        this.webgl = webgl;
        this.options = options;
        this.uTime = { value: 0 };
    }

    createPlane(side, width, isRoad) {
        const options = this.options;
        let segments = 100;
        const geometry = new THREE.PlaneGeometry(
            isRoad ? options.roadWidth : options.islandWidth,
            options.length,
            20,
            segments
        );
        let uniforms = {
            uTravelLength: { value: options.length },
            uColor: { value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor) },
            uTime: this.uTime
        };

        if (isRoad) {
            uniforms = Object.assign(uniforms, {
                uLanes: { value: options.lanesPerRoad },
                uBrokenLinesColor: { value: new THREE.Color(options.colors.brokenLines) },
                uShoulderLinesColor: { value: new THREE.Color(options.colors.shoulderLines) },
                uShoulderLinesWidthPercentage: { value: options.shoulderLinesWidthPercentage },
                uBrokenLinesLengthPercentage: { value: options.brokenLinesLengthPercentage },
                uBrokenLinesWidthPercentage: { value: options.brokenLinesWidthPercentage }
            });
        }

        const material = new THREE.ShaderMaterial({
            fragmentShader: isRoad ? roadFragment : islandFragment,
            vertexShader: roadVertex,
            side: THREE.DoubleSide,
            uniforms: Object.assign(uniforms, this.webgl.fogUniforms, options.distortion.uniforms)
        });

        material.onBeforeCompile = shader => {
            shader.vertexShader = shader.vertexShader.replace(
                '#include <getDistortion_vertex>',
                options.distortion.getDistortion
            );
        };

        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.z = -options.length / 2;
        mesh.position.x += (this.options.islandWidth / 2 + options.roadWidth / 2) * side;
        this.webgl.scene.add(mesh);

        return mesh;
    }

    init() {
        this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);
        this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);
        this.island = this.createPlane(0, this.options.islandWidth, false);
    }

    update(time) {
        this.uTime.value = time;
    }
}

const roadBaseFragment = `
    #define USE_FOG;
    varying vec2 vUv; 
    uniform vec3 uColor;
    uniform float uTime;
    #include <roadMarkings_vars>
    ${THREE.ShaderChunk['fog_pars_fragment']}
    void main() {
        vec2 uv = vUv;
        vec3 color = vec3(uColor);
        #include <roadMarkings_fragment>
        gl_FragColor = vec4(color, 1.);
        ${THREE.ShaderChunk['fog_fragment']}
    }
`;

const islandFragment = roadBaseFragment
    .replace('#include <roadMarkings_fragment>', '')
    .replace('#include <roadMarkings_vars>', '');

const roadMarkings_vars = `
    uniform float uLanes;
    uniform vec3 uBrokenLinesColor;
    uniform vec3 uShoulderLinesColor;
    uniform float uShoulderLinesWidthPercentage;
    uniform float uBrokenLinesWidthPercentage;
    uniform float uBrokenLinesLengthPercentage;
    highp float random(vec2 co) {
        highp float a = 12.9898;
        highp float b = 78.233;
        highp float c = 43758.5453;
        highp float dt = dot(co.xy, vec2(a, b));
        highp float sn = mod(dt, 3.14);
        return fract(sin(sn) * c);
    }
`;

const roadMarkings_fragment = `
    uv.y = mod(uv.y + uTime * 0.05, 1.);
    float laneWidth = 1.0 / uLanes;
    float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;
    float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;

    float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));
    float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);

    brokenLines = mix(brokenLines, sideLines, uv.x);
`;

const roadFragment = roadBaseFragment
    .replace('#include <roadMarkings_fragment>', roadMarkings_fragment)
    .replace('#include <roadMarkings_vars>', roadMarkings_vars);

const roadVertex = `
    #define USE_FOG;
    uniform float uTime;
    ${THREE.ShaderChunk['fog_pars_vertex']}
    uniform float uTravelLength;
    varying vec2 vUv; 
    #include <getDistortion_vertex>
    void main() {
        vec3 transformed = position.xyz;
        vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);
        transformed.x += distortion.x;
        transformed.z += distortion.y;
        transformed.y += -1. * distortion.z;  
        
        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);
        gl_Position = projectionMatrix * mvPosition;
        vUv = uv;
        ${THREE.ShaderChunk['fog_vertex']}
    }
`;

function resizeRendererToDisplaySize(renderer, setSize) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
        setSize(width, height, false);
    }
    return needResize;
}

class App {
    constructor(container, options = {}) {
        this.options = options;
        this.container = container;
        this.renderer = new THREE.WebGLRenderer({
            antialias: false,
            alpha: true
        });
        this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.composer = new EffectComposer(this.renderer);
        container.appendChild(this.renderer.domElement);

        this.camera = new THREE.PerspectiveCamera(
            options.fov,
            container.offsetWidth / container.offsetHeight,
            0.1,
            10000
        );
        this.camera.position.z = -5;
        this.camera.position.y = 8;
        this.camera.position.x = 0;
        this.scene = new THREE.Scene();
        this.scene.background = null;

        let fog = new THREE.Fog(options.colors.background, options.length * 0.2, options.length * 500);
        this.scene.fog = fog;
        this.fogUniforms = {
            fogColor: { value: fog.color },
            fogNear: { value: fog.near },
            fogFar: { value: fog.far }
        };
        this.clock = new THREE.Clock();
        this.assets = {};
        this.disposed = false;

        this.road = new Road(this, options);
        this.leftCarLights = new CarLights(
            this,
            options,
            options.colors.leftCars,
            options.movingAwaySpeed,
            new THREE.Vector2(0, 1 - options.carLightsFade)
        );
        this.rightCarLights = new CarLights(
            this,
            options,
            options.colors.rightCars,
            options.movingCloserSpeed,
            new THREE.Vector2(1, 0 + options.carLightsFade)
        );
        this.leftSticks = new LightsSticks(this, options);

        this.fovTarget = options.fov;
        this.speedUpTarget = 0;
        this.speedUp = 0;
        this.timeOffset = 0;

        this.tick = this.tick.bind(this);
        this.init = this.init.bind(this);
        this.setSize = this.setSize.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onWindowResize = this.onWindowResize.bind(this);

        window.addEventListener('resize', this.onWindowResize);
    }

    onWindowResize() {
        const width = this.container.offsetWidth;
        const height = this.container.offsetHeight;

        this.renderer.setSize(width, height);
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.composer.setSize(width, height);
    }

    initPasses() {
        this.renderPass = new RenderPass(this.scene, this.camera);
        this.bloomPass = new EffectPass(
            this.camera,
            new BloomEffect({
                luminanceThreshold: 0.2,
                luminanceSmoothing: 0,
                resolutionScale: 1
            })
        );

        const smaaPass = new EffectPass(
            this.camera,
            new SMAAEffect({
                preset: SMAAPreset.MEDIUM
            })
        );
        this.renderPass.renderToScreen = false;
        this.bloomPass.renderToScreen = false;
        smaaPass.renderToScreen = true;
        this.composer.addPass(this.renderPass);
        this.composer.addPass(this.bloomPass);
        this.composer.addPass(smaaPass);
    }

    loadAssets() {
        const assets = this.assets;
        return new Promise(resolve => {
            const manager = new THREE.LoadingManager(resolve);

            const searchImage = new Image();
            const areaImage = new Image();
            assets.smaa = {};
            searchImage.addEventListener('load', function () {
                assets.smaa.search = this;
                manager.itemEnd('smaa-search');
            });

            areaImage.addEventListener('load', function () {
                assets.smaa.area = this;
                manager.itemEnd('smaa-area');
            });
            manager.itemStart('smaa-search');
            manager.itemStart('smaa-area');

            searchImage.src = SMAAEffect.searchImageDataURL;
            areaImage.src = SMAAEffect.areaImageDataURL;
        });
    }

    init() {
        this.initPasses();
        const options = this.options;
        this.road.init();
        this.leftCarLights.init();

        this.leftCarLights.mesh.position.setX(-options.roadWidth / 2 - options.islandWidth / 2);
        this.rightCarLights.init();
        this.rightCarLights.mesh.position.setX(options.roadWidth / 2 + options.islandWidth / 2);
        this.leftSticks.init();
        this.leftSticks.mesh.position.setX(-(options.roadWidth + options.islandWidth / 2));

        this.container.addEventListener('mousedown', this.onMouseDown);
        this.container.addEventListener('mouseup', this.onMouseUp);
        this.container.addEventListener('mouseout', this.onMouseUp);

        this.container.addEventListener('touchstart', this.onTouchStart, { passive: true });
        this.container.addEventListener('touchend', this.onTouchEnd, { passive: true });
        this.container.addEventListener('touchcancel', this.onTouchEnd, { passive: true });
        this.container.addEventListener('contextmenu', this.onContextMenu);

        this.tick();
    }

    onMouseDown(ev) {
        if (this.options.onSpeedUp) this.options.onSpeedUp(ev);
        this.fovTarget = this.options.fovSpeedUp;
        this.speedUpTarget = this.options.speedUp;
    }

    onMouseUp(ev) {
        if (this.options.onSlowDown) this.options.onSlowDown(ev);
        this.fovTarget = this.options.fov;
        this.speedUpTarget = 0;
    }

    onTouchStart(ev) {
        if (this.options.onSpeedUp) this.options.onSpeedUp(ev);
        this.fovTarget = this.options.fovSpeedUp;
        this.speedUpTarget = this.options.speedUp;
    }

    onTouchEnd(ev) {
        if (this.options.onSlowDown) this.options.onSlowDown(ev);
        this.fovTarget = this.options.fov;
        this.speedUpTarget = 0;
    }

    onContextMenu(ev) {
        ev.preventDefault();
    }

    update(delta) {
        let lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);
        this.speedUp += lerp(this.speedUp, this.speedUpTarget, lerpPercentage, 0.00001);
        this.timeOffset += this.speedUp * delta;

        let time = this.clock.elapsedTime + this.timeOffset;

        this.rightCarLights.update(time);
        this.leftCarLights.update(time);
        this.leftSticks.update(time);
        this.road.update(time);

        let updateCamera = false;
        let fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);
        if (fovChange !== 0) {
            this.camera.fov += fovChange * delta * 6;
            updateCamera = true;
        }

        if (this.options.distortion.getJS) {
            const distortion = this.options.distortion.getJS(0.025, time);

            this.camera.lookAt(
                new THREE.Vector3(
                    this.camera.position.x + distortion.x,
                    this.camera.position.y + distortion.y,
                    this.camera.position.z + distortion.z
                )
            );
            updateCamera = true;
        }
        if (updateCamera) {
            this.camera.updateProjectionMatrix();
        }
    }

    render(delta) {
        this.composer.render(delta);
    }

    dispose() {
        this.disposed = true;

        if (this.renderer) {
            this.renderer.dispose();
        }
        if (this.composer) {
            this.composer.dispose();
        }
        if (this.scene) {
            this.scene.clear();
        }

        window.removeEventListener('resize', this.onWindowResize);
        if (this.container) {
            this.container.removeEventListener('mousedown', this.onMouseDown);
            this.container.removeEventListener('mouseup', this.onMouseUp);
            this.container.removeEventListener('mouseout', this.onMouseUp);

            this.container.removeEventListener('touchstart', this.onTouchStart);
            this.container.removeEventListener('touchend', this.onTouchEnd);
            this.container.removeEventListener('touchcancel', this.onTouchEnd);
            this.container.removeEventListener('contextmenu', this.onContextMenu);
        }
    }

    setSize(width, height, updateStyles) {
        this.composer.setSize(width, height, updateStyles);
    }

    tick() {
        if (this.disposed || !this) return;
        if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {
            const canvas = this.renderer.domElement;
            this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
            this.camera.updateProjectionMatrix();
        }
        const delta = this.clock.getDelta();
        this.render(delta);
        this.update(delta);
        requestAnimationFrame(this.tick);
    }
}

// Initialize Hyperspeed
const container = document.getElementById('hyperspeed-container');
const options = { ...effectOptions };
options.distortion = distortions[options.distortion];

const hyperspeedApp = new App(container, options);
hyperspeedApp.loadAssets().then(hyperspeedApp.init);

// Store reference for cleanup
window.hyperspeedApp = hyperspeedApp;
</script>

<!-- Main Site Scripts -->
<script>
const API_URL = 'https://abysslink.onrender.com';

gsap.registerPlugin(ScrollTrigger);

ScrollTrigger.config({
    autoRefreshEvents: "visibilitychange,DOMContentLoaded,load",
    ignoreMobileResize: true
});

window.addEventListener("load", () => {
    window.scrollTo(0, 0);
    setTimeout(() => {
        ScrollTrigger.refresh();
        initializeAnimations();
    }, 100);
});

function initializeAnimations() {
    // Set initial states
    gsap.set("#warrior-img", {
        opacity: 0,
        y: 200,
        scale: 0.9
    });

    gsap.set("#sword-img", {
        opacity: 0,
        y: 60
    });

    // Warrior fade in on load
    gsap.to("#warrior-img", {
        opacity: 1,
        y: 0,
        scale: 1,
        duration: 1.8,
        ease: "power2.out",
        delay: 0.2,
        force3D: true
    });

    // Warrior fade out on scroll
    gsap.to("#warrior-img", {
        scrollTrigger: {
            trigger: "#hero",
            start: "top top",
            end: "bottom top",
            scrub: 1,
            invalidateOnRefresh: true
        },
        opacity: 0,
        y: -80,
        scale: 1.1,
        ease: "none",
        force3D: true
    });

    // Hyperspeed fade out on scroll
    gsap.to("#hyperspeed-container", {
        scrollTrigger: {
            trigger: "#hero",
            start: "top top",
            end: "bottom top",
            scrub: 1,
            invalidateOnRefresh: true
        },
        opacity: 0,
        ease: "none"
    });

    // Original background fade in
    gsap.to("#originalBackground", {
        scrollTrigger: {
            trigger: "#hero",
            start: "center top",
            end: "bottom top",
            scrub: 1,
            invalidateOnRefresh: true,
            onEnter: () => {
                document.getElementById('originalBackground').classList.add('visible');
            },
            onLeaveBack: () => {
                document.getElementById('originalBackground').classList.remove('visible');
            }
        },
        opacity: 1,
        ease: "none"
    });

    // Sword fade in - smooth and responsive
    gsap.to("#sword-img", {
        scrollTrigger: {
            trigger: "#hero",
            start: "bottom 95%",
            end: "bottom 40%",
            scrub: 1,
            invalidateOnRefresh: true
        },
        opacity: 0.95,
        y: 0,
        ease: "none",
        force3D: true
    });

    // Sword fade out - separate trigger
    gsap.to("#sword-img", {
        scrollTrigger: {
            trigger: "#security",
            start: "top 85%",
            end: "top 35%",
            scrub: 1,
            invalidateOnRefresh: true
        },
        opacity: 0,
        y: -50,
        ease: "none",
        force3D: true
    });

    // Background blur animation
    gsap.to("#bg-image", {
        scrollTrigger: {
            trigger: "#hero",
            start: "top top",
            end: "bottom top",
            scrub: 1
        },
        filter: "blur(0px) brightness(0.8)",
        ease: "none"
    });

    // Content wrapper animations
    document.querySelectorAll('.content-wrapper').forEach((content, index) => {
        gsap.to(content, {
            scrollTrigger: {
                trigger: content,
                start: "top 85%",
                toggleActions: "play none none reverse"
            },
            opacity: 1,
            y: 0,
            duration: 0.8,
            ease: "power2.out",
            delay: index * 0.05,
            force3D: true
        });
    });

    // Glass pane animations
    gsap.utils.toArray('.glass-pane').forEach((pane, i) => {
        gsap.from(pane, {
            scrollTrigger: {
                trigger: pane,
                start: "top 90%",
                toggleActions: "play none none reverse"
            },
            opacity: 0,
            y: 25,
            duration: 0.6,
            delay: i * 0.08,
            ease: "power2.out",
            force3D: true
        });
    });

    // Card animations
    gsap.utils.toArray('.card').forEach((card, i) => {
        gsap.from(card, {
            scrollTrigger: {
                trigger: card,
                start: "top 90%",
                toggleActions: "play none none reverse"
            },
            opacity: 0,
            y: 25,
            duration: 0.6,
            delay: i * 0.06,
            ease: "power2.out",
            force3D: true
        });
    });
}

// Glitch text effect
function pulsingWaveGlitch(element) {
    const text = element.dataset.text || element.textContent;
    const chars = '/\\|_-<>[]{}';

    element.innerHTML = '';

    const spans = text.split('').map(char => {
        const span = document.createElement('span');
        span.className = 'glitch-char';
        span.textContent = char;
        span.dataset.original = char;
        element.appendChild(span);
        return span;
    });

    let waveIndex = 0;
    let lastTime = 0;
    const interval = 120;

    function animate(currentTime) {
        if (currentTime - lastTime >= interval) {
            spans.forEach((span, i) => {
                const distance = Math.abs(i - waveIndex);
                const isInWave = distance < 4;

                if (isInWave && Math.random() > 0.3) {
                    span.textContent = chars[Math.floor(Math.random() * chars.length)];
                    span.style.opacity = 0.6 + Math.random() * 0.4;
                } else if (!isInWave) {
                    span.textContent = span.dataset.original;
                    span.style.opacity = '1';
                }
            });

            waveIndex = (waveIndex + 1) % (spans.length + 5);
            lastTime = currentTime;
        }
        requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
}

document.querySelectorAll('.glitch-text').forEach(el => pulsingWaveGlitch(el));

// Navigation scroll tracking
let scrollTimeout;
const navItems = document.querySelectorAll('.sticky-nav .nav-item');
const sections = document.querySelectorAll('section[id]');

function updateActiveNav() {
    let current = '';
    sections.forEach(section => {
        const sectionTop = section.offsetTop;
        if (window.pageYOffset >= sectionTop - 300) {
            current = section.getAttribute('id');
        }
    });

    navItems.forEach(item => {
        item.classList.remove('active');
        if (item.getAttribute('data-section') === current) {
            item.classList.add('active');
        }
    });
}

window.addEventListener('scroll', () => {
    if (scrollTimeout) {
        window.cancelAnimationFrame(scrollTimeout);
    }
    scrollTimeout = window.requestAnimationFrame(updateActiveNav);
}, { passive: true });

// Menu toggle
const menuToggle = document.getElementById('menuToggle');
const menuOverlay = document.getElementById('menuOverlay');

menuToggle.addEventListener('click', () => {
    menuToggle.classList.toggle('active');
    menuOverlay.classList.toggle('active');
});

function closeMenu() {
    menuToggle.classList.remove('active');
    menuOverlay.classList.remove('active');
}

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        closeMenu();
    }
});

// Smooth scroll for anchor links
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            closeMenu();
        }
    });
});

// Refresh ScrollTrigger on resize
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        ScrollTrigger.refresh();
    }, 250);
}, { passive: true });
</script>

</body>
</html>
