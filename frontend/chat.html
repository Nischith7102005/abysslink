<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Session Active â€” AbyssLink</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;400;600;800&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
<style>
:root {
--bg: #050505;
--surface: #0a0a0a;
--text-main: #ffffff;
--text-dim: #888888;
--border: #222222;
--accent: #ffffff;
--danger: #ff4444;
--ease-out: cubic-bezier(0.23, 1, 0.32, 1);
}
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
background-color: var(--bg);
color: var(--text-main);
font-family: 'Manrope', sans-serif;
overflow: hidden;
-webkit-font-smoothing: antialiased;
height: 100vh;
display: flex;
flex-direction: column;
}
.loading {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: var(--bg);
display: flex;
align-items: center;
justify-content: center;
z-index: 9999;
}
.loading-spinner {
width: 40px;
height: 40px;
border: 2px solid var(--border);
border-top-color: var(--text-main);
border-radius: 50%;
animation: spin 1s linear infinite;
margin: 0 auto 1rem;
}
@keyframes spin {
to { transform: rotate(360deg); }
}
.loading-text {
font-family: 'Space Mono', monospace;
font-size: 0.9rem;
text-transform: uppercase;
color: var(--text-dim);
letter-spacing: 0.1em;
}
.chat-header {
background: var(--surface);
border-bottom: 1px solid var(--border);
padding: 1.5rem 2rem;
display: flex;
justify-content: space-between;
align-items: center;
flex-wrap: wrap;
gap: 1rem;
}
.room-info h2 {
font-family: 'Space Mono', monospace;
font-size: clamp(1rem, 2vw, 1.3rem);
font-weight: 700;
letter-spacing: -0.02em;
text-transform: uppercase;
margin-bottom: 0.3rem;
}
.room-meta {
font-family: 'Space Mono', monospace;
font-size: 0.75rem;
color: var(--text-dim);
text-transform: uppercase;
display: flex;
align-items: center;
gap: 0.5rem;
}
.copy-btn {
font-family: 'Space Mono', monospace;
font-size: 0.7rem;
padding: 0.2rem 0.5rem;
background: transparent;
color: var(--text-dim);
border: 1px solid var(--border);
cursor: pointer;
transition: all 0.2s ease;
}
.copy-btn:hover {
color: var(--text-main);
border-color: var(--text-main);
}
.header-right {
display: flex;
align-items: center;
gap: 1rem;
}
.status-badge {
font-family: 'Space Mono', monospace;
font-size: 0.75rem;
padding: 0.5rem 1rem;
border: 1px solid var(--border);
background: var(--bg);
text-transform: uppercase;
letter-spacing: 0.05em;
}
.status-badge.timer {
color: var(--danger);
border-color: rgba(255, 68, 68, 0.3);
}
.status-badge.participants {
color: var(--text-main);
}
.chat-container {
flex: 1;
display: flex;
overflow: hidden;
}
.messages {
flex: 1;
overflow-y: auto;
padding: 2rem;
display: flex;
flex-direction: column;
gap: 1rem;
}
.message {
max-width: 65%;
padding: 1rem 1.5rem;
animation: slideIn 0.4s var(--ease-out);
word-wrap: break-word;
}
@keyframes slideIn {
from { opacity: 0; transform: translateY(20px); }
to { opacity: 1; transform: translateY(0); }
}
.message.own {
align-self: flex-end;
background: var(--text-main);
color: var(--bg);
}
.message.other {
align-self: flex-start;
background: var(--surface);
border: 1px solid var(--border);
}
.message-text {
margin-bottom: 0.5rem;
line-height: 1.6;
font-size: 0.95rem;
}
.message-time {
font-family: 'Space Mono', monospace;
font-size: 0.65rem;
opacity: 0.5;
text-transform: uppercase;
}
.system-message {
align-self: center;
background: transparent;
border-top: 1px solid var(--border);
border-bottom: 1px solid var(--border);
padding: 0.75rem 1.5rem;
font-family: 'Space Mono', monospace;
font-size: 0.75rem;
color: var(--text-dim);
text-transform: uppercase;
letter-spacing: 0.1em;
max-width: 100%;
text-align: center;
}
.input-area {
padding: 1.5rem 2rem;
background: var(--surface);
border-top: 1px solid var(--border);
display: flex;
gap: 1rem;
align-items: center;
}
.input-area input[type="text"] {
flex: 1;
padding: 1rem 1.5rem;
border: 1px solid var(--border);
background: var(--bg);
color: var(--text-main);
font-family: 'Manrope', sans-serif;
font-size: 0.95rem;
outline: none;
}
.input-area input[type="text"]:focus {
border-color: var(--text-main);
background: var(--surface);
}
.input-area input[type="text"]::placeholder {
color: var(--text-dim);
}
.btn {
font-family: 'Space Mono', monospace;
font-size: 0.8rem;
text-transform: uppercase;
font-weight: 700;
padding: 1rem 1.5rem;
border: 1px solid var(--border);
background: transparent;
color: var(--text-main);
cursor: pointer;
transition: all 0.3s var(--ease-out);
white-space: nowrap;
}
.btn:hover {
background: var(--text-main);
color: var(--bg);
transform: translateY(-2px);
}
.btn-primary {
background: var(--text-main);
color: var(--bg);
}
.btn-danger {
border-color: var(--danger);
color: var(--danger);
}
.btn-danger:hover {
background: var(--danger);
color: var(--text-main);
}
.sidebar {
width: 300px;
background: var(--surface);
border-left: 1px solid var(--border);
padding: 2rem;
display: flex;
flex-direction: column;
gap: 2rem;
}
.sidebar h3 {
font-family: 'Space Mono', monospace;
font-size: 0.85rem;
text-transform: uppercase;
letter-spacing: 0.1em;
margin-bottom: 1rem;
color: var(--text-dim);
border-bottom: 1px solid var(--border);
padding-bottom: 0.5rem;
}
.info-box {
background: var(--bg);
padding: 1.5rem;
border: 1px solid var(--border);
}
.info-box p {
font-family: 'Space Mono', monospace;
color: var(--text-dim);
font-size: 0.75rem;
margin-bottom: 0.5rem;
text-transform: uppercase;
}
.info-box strong {
font-family: 'Space Mono', monospace;
color: var(--text-main);
font-size: 1.5rem;
font-weight: 700;
}
.action-buttons {
margin-top: auto;
padding-top: 2rem;
border-top: 1px solid var(--border);
}
.error-message {
position: fixed;
top: 20px;
right: 20px;
background: var(--danger);
color: white;
padding: 1rem 2rem;
border-radius: 4px;
font-family: 'Space Mono', monospace;
z-index: 1000;
animation: slideIn 0.3s ease;
}
@keyframes slideIn {
from { transform: translateX(100%); opacity: 0; }
to { transform: translateX(0); opacity: 1; }
}
@media (max-width: 968px) {
.sidebar { display: none; }
.message { max-width: 80%; }
}
@media (max-width: 600px) {
.chat-header { padding: 1rem; }
.input-area { padding: 1rem; flex-wrap: wrap; }
.input-area input[type="text"] { width: 100%; }
.btn { padding: 0.75rem 1rem; font-size: 0.75rem; }
.message { max-width: 90%; }
}
</style>
</head>
<body>
<div id="loadingScreen" class="loading">
<div class="loading-content">
<div class="loading-spinner"></div>
<div class="loading-text">Joining Session...</div>
</div>
</div>
<div id="chatApp" style="display:none; height:100%; flex-direction:column;">
<div class="chat-header">
<div class="room-info">
<h2 id="roomTopic">Untitled Session</h2>
<div class="room-meta">
Key: <span id="roomKeyDisplay"></span>
<button class="copy-btn" onclick="copyFullKey(event)">Copy Full</button>
</div>
</div>
<div class="header-right">
<div class="status-badge participants"><span id="participantCount">0</span> Active</div>
<div class="status-badge timer" id="timerBadge"><span id="timeRemaining">24:00:00</span></div>
</div>
</div>
<div class="chat-container">
<div style="flex:1; display:flex; flex-direction:column;">
<div class="messages" id="messages"></div>
<div class="input-area">
<input type="file" id="fileInput" style="display:none;" onchange="handleFileSelect()">
<button class="btn" onclick="document.getElementById('fileInput').click()">Attach</button>
<input type="text" id="messageInput" placeholder="Compose message..." onkeypress="handleKeyPress(event)">
<button class="btn btn-primary" onclick="sendMessage()">Send</button>
</div>
</div>
<div class="sidebar">
<div>
<h3>Session Status</h3>
<div class="info-box">
<p>Active Participants</p>
<strong><span id="sidebarParticipants">0</span></strong>
</div>
</div>
<div class="action-buttons">
<button class="btn" onclick="leaveRoom()">Exit Session</button>
<button class="btn btn-danger" onclick="confirmVanish()">Destroy Room</button>
</div>
</div>
</div>
</div>
<script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>
<script>
const API_URL = 'https://abysslink.onrender.com';
const SOCKET_URL = 'https://abysslink.onrender.com';
const urlParams = new URLSearchParams(window.location.search);
const roomId = urlParams.get('room');
const password = urlParams.get('password');
const topic = urlParams.get('topic');
if (!roomId || !password) {
  alert('Missing room key or password');
  window.location.href = 'rooms.html';
}

let socket = null;
let myId = null;
let expiresAt = null;
let timer = null;

function showError(message) {
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error-message';
  errorDiv.textContent = message;
  errorDiv.onclick = () => errorDiv.remove();
  document.body.appendChild(errorDiv);
  setTimeout(() => errorDiv.remove(), 5000);
}

function copyFullKey(event) {
  navigator.clipboard.writeText(roomId).then(() => {
    const btn = event.target;
    const originalText = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = originalText; }, 2000);
  }).catch(err => {
    console.error('Copy failed:', err);
    showError('Failed to copy key');
  });
}

// ðŸ” E2EE: Derive key from room ID + password
async function deriveEncryptionKey() {
  const encoder = new TextEncoder();
  const data = encoder.encode(roomId + password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return hash;
}

// ðŸ” Encrypt message
async function encryptMessage(plaintext) {
  const key = await deriveEncryptionKey();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(plaintext);
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt']),
    encoded
  );
  const ivB64 = btoa(String.fromCharCode(...iv));
  const ctB64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
  return { iv: ivB64, ciphertext: ctB64 };
}

// ðŸ” Decrypt message
async function decryptMessage(ivB64, ciphertextB64) {
  try {
    const key = await deriveEncryptionKey();
    const iv = new Uint8Array(atob(ivB64).split('').map(c => c.charCodeAt(0)));
    const ciphertext = new Uint8Array(atob(ciphertextB64).split('').map(c => c.charCodeAt(0)));
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['decrypt']),
      ciphertext
    );
    return new TextDecoder().decode(decrypted);
  } catch (err) {
    console.warn('Decryption failed:', err.message);
    return '[Decryption failed]';
  }
}

function initialize() {
  document.getElementById('loadingScreen').style.display = 'none';
  document.getElementById('chatApp').style.display = 'flex';
  document.getElementById('roomTopic').textContent = decodeURIComponent(topic || 'Untitled Session');
  document.getElementById('roomKeyDisplay').textContent = roomId.substring(0, 8).toUpperCase();

  socket = io(SOCKET_URL, {
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000
  });

  socket.on('connect', () => {
    myId = socket.id;
    socket.emit('join_room', { roomId, password });
  });

  socket.on('connect_error', (error) => {
    console.error('Connection error:', error);
    showError('Failed to connect to chat server');
  });

  socket.on('join_success', (data) => {
    expiresAt = data.expiresAt;
    updateParticipants(data.participantCount || 1);
    updateTimer();
  });

  socket.on('error', (message) => {
    console.error('Socket error:', message);
    showError(message);
    if (message.includes('password') || message.includes('found')) {
      cleanupAndRedirect();
    }
  });

  socket.on('new_message', async (msg) => {
    if (msg.type === 'system') {
      addMessage(msg);
      return;
    }
    let displayText = msg.text; // fallback (legacy)
    if (msg.encrypted) {
      displayText = await decryptMessage(msg.encrypted.iv, msg.encrypted.ciphertext);
    }
    addMessage({ ...msg, text: displayText });
  });

  socket.on('participant_joined', (data) => {
    updateParticipants(data.count);
    if (data.message) addMessage({ id: Date.now().toString(), text: data.message, timestamp: Date.now(), type: 'system' });
  });

  socket.on('participant_left', (data) => {
    updateParticipants(data.count);
    if (data.message) addMessage({ id: Date.now().toString(), text: data.message, timestamp: Date.now(), type: 'system' });
  });

  socket.on('room_vanished', () => {
    showError('Room has been destroyed.');
    cleanupAndRedirect();
  });

  socket.on('file_uploaded', (fileData) => {
    addMessage({
      id: fileData.id,
      text: `ðŸ“Ž ${fileData.name} (${formatFileSize(fileData.size)})`,
      timestamp: fileData.uploadedAt,
      sender: 'system',
      isFile: true
    });
  });
}

function addMessage(msg) {
  const el = document.createElement('div');
  el.className = msg.type === 'system' ? 'system-message' :
    (msg.sender === myId ? 'message own' : 'message other');
  if (msg.type === 'system') {
    el.textContent = msg.text;
  } else {
    const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    el.innerHTML = `<div class="message-text">${escape(msg.text)}</div><div class="message-time">${time}</div>`;
  }
  document.getElementById('messages').appendChild(el);
  el.scrollIntoView({ behavior: 'smooth' });
}

function updateParticipants(count) {
  document.getElementById('participantCount').textContent = count;
  document.getElementById('sidebarParticipants').textContent = count;
}

// âœ… SEND ENCRYPTED MESSAGE
async function sendMessage() {
  const input = document.getElementById('messageInput');
  const text = input.value.trim();
  if (!text) return;

  try {
    const encrypted = await encryptMessage(text);
    socket.emit('send_message', { roomId, encrypted });
    input.value = '';
  } catch (err) {
    showError('Failed to encrypt message');
    console.error(err);
  }
}

function handleKeyPress(e) {
  if (e.key === 'Enter') sendMessage();
}

function handleFileSelect() {
  alert('File sharing is disabled in this version for simplicity.');
  document.getElementById('fileInput').value = '';
}

function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function updateTimer() {
  if (!expiresAt) return;
  const now = Date.now();
  const remaining = expiresAt - now;
  if (remaining <= 0) {
    showError('Session expired.');
    cleanupAndRedirect();
    return;
  }
  const h = Math.floor(remaining / 3600000);
  const m = Math.floor((remaining % 3600000) / 60000);
  const s = Math.floor((remaining % 60000) / 1000);
  document.getElementById('timeRemaining').textContent =
    `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
  if (remaining < 300000) {
    document.getElementById('timerBadge').style.borderColor = 'var(--danger)';
    document.getElementById('timerBadge').style.color = 'var(--danger)';
  }
  timer = setTimeout(updateTimer, 1000);
}

function confirmVanish() {
  if (confirm('Destroy this room for everyone? This cannot be undone.')) {
    fetch(`${API_URL}/api/rooms/vanish`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ roomId, password })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        showError('Room destruction initiated.');
        cleanupAndRedirect();
      } else {
        showError('Failed to vanish room');
      }
    })
    .catch(err => {
      console.error('Vanish error:', err);
      showError('Failed to vanish room');
    });
  }
}

function leaveRoom() {
  if (confirm('Leave this session?')) {
    cleanupAndRedirect();
  }
}

function cleanupAndRedirect() {
  if (timer) clearTimeout(timer);
  if (socket) socket.disconnect();
  window.location.href = 'rooms.html';
}

function escape(str) {
  return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m]));
}

document.addEventListener('visibilitychange', () => {
  if (!document.hidden && expiresAt) updateTimer();
});

window.addEventListener('beforeunload', () => {
  if (socket) socket.disconnect();
});

initialize();
</script>
</body>
</html>
